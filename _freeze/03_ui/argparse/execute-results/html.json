{
  "hash": "cbd346f9629e9fe4da93745e3f8afede",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: '2. Writing executable scripts with Argparse'\njupyter: python3\norder: 2\n---\n\n\nObjectives: learn how to use `argparse` to write more sophisticated Python scripts.\n\n## Intro to argparse\n\nIn all of the Python scripts we've written so far we have *hardcoded* various options, such as a file to load. By hardcode, we mean that the user has no input as to what the script should do at *runtime*; everything is pre-coded before hand. This makes for some rather limited scripts, since you would need to re-write a script everytime you want to change anything.\n\nThe only bit of user-input at runtime we've seen before is by using the `input` argument. But this is somewhat clunky, as the program will stop until the user inputs something. It makes batch computing (in which you run the same script a bunch of times just chaning the input)  difficult, for example.\n\nIn bash, we have seen that it's possible to provide *arguments* to commands to get them to change their default behavior. For example, running `ls` will list the contents of the current directory, whereas running `ls folder` will list the contents of `folder` instead. In this case, `folder` is known as a *positional argument*. We've also seen that it's possible to provide *optional* arguments to bash commands to get the to change their behavior. For example, running `rm folder` will fail because the default `rm` cannot delete folders, but running `rm -r folder` will work. The `-r` tells `rm` to recursively remove everything in `folder` followed by `folder` itself.\n\nIt would be wonderful if we could also provide positional and optional arguments to our Python scripts so that the user can change how the script behaves at runtime. Fortunately, we can! Enter [argparse](https://docs.python.org/3/library/argparse.html). Argparse is an in-built module that provides the ability to add arguments (both required and optional) to your scripts. It allows you to write more fully featured, sophisticated Python scripts. The Python docs have an [excellent tutorial on argparse](https://docs.python.org/3/howto/argparse.html). Here, we'll just cover some of the basics.\n\n\nThe basic steps to using argparse in your script are:\n\n1. Import `argparse`.\n2. Create an `argparse.ArgumentParser` instance.\n3. Add options to the parser.\n4. Parse the user input. You can then use the user input in your script.\n\nBelow we'll see some examples to get you acquainted with it.\n\n## Positional arguments\n\nHere's a simple example, which we'll call `echo.py`:\n\n::: {#839af8e5 .cell execution_count=1}\n``` {.python .cell-code}\n# echo.py\nimport argparse\n\nparser = argparse.ArgumentParser()\nparser.add_argument('echo')\nargs = parser.parse_args()\n\nprint(args.echo)\n```\n:::\n\n\nThis adds a single *positional argument* to our script called `echo`. To use it, on the command line we run:\n\n```{bash}\npython echo.py hello\n```\n\nYou should get back `hello`. As you can see, whatever the user provides after the name of the script is mapped to the `echo` argument, which can then be accessed from within the program via `args.echo`. As with bash commands, spaces determine what counts as different arguments. For example, if you try running:\n\n```{bash}\npython echo.py hello world\n```\n\nYou get an error:\n```{text}\nusage: echo.py [-h] echo\necho.py: error: unrecognized arguments: world\n```\n\nThis is because `argparse` sees \"world\" as a second argument, but since the script only takes one argument (`echo`), it doesn't know what to do with it. To pass space-separated strings as a single argument, you need to encase them in quotes, just as we do with other bash commands. In this case, running:\n\n```{bash}\npython echo.py \"hello world\"\n```\n\nworks; you'll get back `hello world`.\n\nAlternatively, we could add a *second* positional argument to our program, call it echo2:\n\n::: {#b0e272ea .cell execution_count=2}\n``` {.python .cell-code}\n# echo2.py\nimport argparse\n\nparser = argparse.ArgumentParser()\nparser.add_argument('echo1')\nparser.add_argument('echo2')\nargs = parser.parse_args()\n\nprint(args.echo1, args.echo2)\n```\n:::\n\n\nNow we can do:\n\n```{bash}\npython echo2.py hello world\n```\n\nIn this case, \"hello\" gets mapped to \"echo1\" and \"world\" gets mapped to echo2. Running with any more or any less arguments will raise an error. (Try it!) This is because, as we've written it, the script expects two and only two input arguments, i.e., two arguments are *required*.\n\n## Multiple args\n\nIf we expect to always pass multiple inputs for a single argument, we can add the `nargs` keyword argument to `parse_arg` to tell it how many inputs to expect. For example, if we want our `echo.py` to take in two inputs, but don't want to create separate arguments for each, we can do:\n\n::: {#6b3c3484 .cell execution_count=3}\n``` {.python .cell-code}\n# echo.py\nimport argparse\n\nparser = argparse.ArgumentParser()\nparser.add_argument('echo', nargs=2)\nargs = parser.parse_args()\n\nprint(args.echo)\n```\n:::\n\n\nNow if we run:\n```{bash}\npython echo.py hello world\n```\nit works, we get:\n```{text}\n['hello', 'world']\n```\n\nNotice that now `args.echo` is a list, with the elements in the list corresponding what was given on the command line. This program will still expect two and only two inputs (try it!). If we instead pass `nargs='*'` to `add_argument`, the argument can take *zero or more* arguments, with no limit. For example:\n\n::: {#8c27f641 .cell execution_count=4}\n``` {.python .cell-code}\n# echo.py\nimport argparse\n\nparser = argparse.ArgumentParser()\nparser.add_argument('echo', nargs='*')\nargs = parser.parse_args()\n\nprint(args.echo)\n```\n:::\n\n\nNow running:\n\n```{bash}\npython echo.py hello world, how are you?\n```\nyields:\n```{text}\n['hello', 'world,', 'how', 'are', 'you?']\n```\n\n## Providing help messages\n\nThe `add_argument` method takes several other keyword arguments aside from `nargs`. One of the most useful is `help`. The help keyword allows you to write a message about what an argument does in the program and how to use it. The user can see the help message by running your script with the argument `-h` or `--help`. In either case, the script will just print the help message then quit. For example, if we add a help to our `echo.py` program:\n\n::: {#28f0774b .cell execution_count=5}\n``` {.python .cell-code}\nimport argparse\n\nparser = argparse.ArgumentParser()\nparser.add_argument('echo', help='The argument to print.')\nargs = parser.parse_args()\n\nprint(args.echo)\n```\n:::\n\n\nThen running:\n```{bash}\npython echo.py -h\n```\nyields:\n\n```{text}\nusage: echo.py [-h] echo\n\npositional arguments:\n  echo        The argument to print.\n\noptions:\n  -h, --help  show this help message and exit\n```\n\nWe can also add a description for the overall program by providing the `description` keyword argument to `ArgumentParser`. For example:\n\n::: {#54a9e824 .cell execution_count=6}\n``` {.python .cell-code}\nimport argparse\n\nparser = argparse.ArgumentParser(description=\"Prints to screen whatever is provided.\")\nparser.add_argument('echo', help='The argument to print.')\nargs = parser.parse_args()\n\nprint(args.echo)\n```\n:::\n\n\nThen\n\n```{bash}\npython echo.py -h\n```\n\nyields:\n\n```{text}\nusage: echo.py [-h] echo\n\nEchoes whatever is provided.\n\npositional arguments:\n  echo        The argument to print.\n\noptions:\n  -h, --help  show this help message and exit\n```\n\nNote that running the script with `-h` or `--help` always works, even if we don't provide a help message for an argument. In that case, the arguments just won't have any informative message in the help, but the user will still at least see what arguments the script takes. The help feature is one of the nice things about `argparse`: it comes in-built; you don't need to add anything extra to get it to work.\n\n## Specifying types\n\nBy default, arguments are assumed to be strings. You can check that yourself: add `print(type(args.echo))` to your `echo.py` script. What if we want to input another datatype, like a float? You can do that by providing the `type` keyword to `add_argument`. For example, say we want our `echo` argument to be a float:\n\n::: {#111e90ca .cell execution_count=7}\n``` {.python .cell-code}\nimport argparse\n\nparser = argparse.ArgumentParser()\nparser.add_argument('echo', help='The argument to print.', type=float)\nargs = parser.parse_args()\n\nprint(args.echo, type(args.echo))\n```\n:::\n\n\nRunning, yields:\n```{bash}\npython echo.py 1\n1.0 <class 'float'>\n```\n\nNote that passing in `python echo.py hello` no longer works in this case, since `hello` cannot be cast to a float.\n\n:::: {.callout-caution appearance=\"simple\" icon=\"false\"}\n### Code Challenge 3.2.1\n\nWrite a Python script called `add.py` that will take two positional arguments as input, `a` and `b` and print their sum. Add help messages to `a` and `b`.\n\n::: {.callout-caution collapse=\"true\" appearance=\"simple\" icon=\"false\"}\n#### Solution\n\n::: {#07e2a20e .cell execution_count=8}\n``` {.python .cell-code}\n# add.py\n\nimport argparse\n\nparser = argparse.ArgumentParser(description=\"Prints the sum of two numbers.\")\nparser.add_argument('a', help='The first value to sum.', type=float)\nparser.add_argument('b', help='The second value to sum.', type=float)\nargs = parser.parse_args()\n\nprint(args.a + args.b)\n```\n:::\n\n\n:::\n::::\n\n\n## Optional arguments\n\nIn addition to positional arguments, `argparse` allows you to define *optional* arguments. These are arguments that start with either a `-` or a `--`. We've already seen one example of an optional argument, the in-built `-h/--help`.\n\nTo add an optional argument, you simply add `--` to the start of the argument name. For example, building on the previous challenge problem, here's a simple math script in which the user can optionally specify what operator to do:\n\n::: {#22503c0f .cell execution_count=9}\n``` {.python .cell-code}\n# calculator.py\n\nimport argparse\n\nparser = argparse.ArgumentParser(description=\"Prints the sum of two numbers.\")\nparser.add_argument('a', help='The first value to sum.', type=float)\nparser.add_argument('b', help='The second value to sum.', type=float)\nparser.add_argument('--operator', default='add', help='What operation to do. Default is add.')\nargs = parser.parse_args()\n\nif args.operator == 'add':\n    res = args.a + args.b\nelif args.operator == 'subtract':\n    res = args.a - args.b\nelif args.operator == 'multiply':\n    res = args.a * args.b\nelif args.operator == 'divide':\n    res = args.a / args.b\nelse:\n    raise ValueError(f\"unrecognized operator {args.operator}\")\nprint(res)\n```\n:::\n\n\nRunning:\n\n```{bash}\npython calculator.py 2 3\n5.0\n```\n\nwhereas:\n\n```{bash}\npython calculator.py 2 3 --operator multiply\n6.0\n```\n\n### Specifying choices\n\nIn the previous example our operator argument should only take four pre-defined possibilities. We can specify those using the `choices` keyword argument. Providing that both provides a more helpful help message, and also negates needing to check that the argument is one of the knowns, since argparse will check for you before the script is even executed. Applying to our `calculator.py` script:\n\n::: {#a3067a03 .cell execution_count=10}\n``` {.python .cell-code}\nimport argparse\n\nparser = argparse.ArgumentParser(description=\"Prints the sum of two numbers.\")\nparser.add_argument('a', help='The first value to sum.', type=float)\nparser.add_argument('b', help='The second value to sum.', type=float)\nparser.add_argument('--operator', default='add', choices=['add', 'multiply', 'divide', 'subtract'],\n                    help='What operation to do. Default is add.')\nargs = parser.parse_args()\n\nif args.operator == 'add':\n    res = args.a + args.b\nelif args.operator == 'subtract':\n    res = args.a - args.b\nelif args.operator == 'multiply':\n    res = args.a * args.b\nelif args.operator == 'divide':\n    res = args.a / args.b\nprint(res)\n```\n:::\n\n\n### Short options\n\nWe can specify short aliases for optional arguments by providing both in the `add_argument`. For example:\n\n::: {#5629ef9a .cell execution_count=11}\n``` {.python .cell-code}\nimport argparse\n\nparser = argparse.ArgumentParser(description=\"Prints the sum of two numbers.\")\nparser.add_argument('a', help='The first value to sum.', type=float)\nparser.add_argument('b', help='The second value to sum.', type=float)\nparser.add_argument('-o', '--operator', default='add', choices=['add', 'multiply', 'divide', 'subtract'],\n                    help='What operation to do. Default is add.')\nargs = parser.parse_args()\n\nif args.operator == 'add':\n    res = args.a + args.b\nelif args.operator == 'subtract':\n    res = args.a - args.b\nelif args.operator == 'multiply':\n    res = args.a * args.b\nelif args.operator == 'divide':\n    res = args.a / args.b\nprint(res)\n```\n:::\n\n\nWe can now run our script by specifying either `-o` or `--operator` for the operator. For example:\n\n```{bash}\npython calculator.py 2 3 -o multiply\n6.0\n```\n\n:::: {.callout-caution appearance=\"simple\" icon=\"false\"}\n### Code Challenge 3.2.2\n\nAdd the ability to `calculator.py` to optionally write the result out to a file. \n\n::: {.callout-caution collapse=\"true\" appearance=\"simple\" icon=\"false\"}\n#### Solution\n\n::: {#698863e1 .cell execution_count=12}\n``` {.python .cell-code}\n# calculator.py\n\nimport argparse\n\nparser = argparse.ArgumentParser(description=\"Prints the sum of two numbers.\")\nparser.add_argument('a', help='The first value to sum.', type=float)\nparser.add_argument('b', help='The second value to sum.', type=float)\nparser.add_argument('-o', '--operator', default='add', choices=['add', 'multiply', 'divide', 'subtract'],\n                    help='What operation to do. Default is add.')\nparser.add_argument('-f', '--output-file', help='Write the result to the given file.')\nargs = parser.parse_args()\n\nif args.operator == 'add':\n    res = args.a + args.b\nelif args.operator == 'subtract':\n    res = args.a - args.b\nelif args.operator == 'multiply':\n    res = args.a * args.b\nelif args.operator == 'divide':\n    res = args.a / args.b\nif args.output_file:\n    with open(args.output_file, 'w') as fp:\n        print(res, file=fp)\nelse:\n    print(res)\n```\n:::\n\n\n:::\n::::\n\n",
    "supporting": [
      "argparse_files"
    ],
    "filters": [],
    "includes": {}
  }
}