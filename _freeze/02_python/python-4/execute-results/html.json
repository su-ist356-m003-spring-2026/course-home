{
  "hash": "64a543e536d800a80e7d21d3c8926491",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: '4. Object Oriented Programming using Python Classes'\njupyter: python3\n---\n\nIn this tutorial we provide an overview of Object oriented programming in Python, including what a `class` is and how to define it. This tutorial is derived from a session during the [Winter 2024 SU OSPO Advanced Python Workshop](https://github.com/SyracuseUniversity/ospo-workshop-advpython/blob/main/session1/tutorial.ipynb). \n \nIn addition, the Appendix provides some more background on common decorators and different ways to define and call functions.\n\n\n## Namespaces and scope\n\nBefore introducing classes, it is instructive to understand how mappings between objects and values are handled in python.\n\nSuppose we create a function called `linef` that calculate the y-value of a line given a slope, y-intercept, and x-value:\n\n::: {#05b05415 .cell execution_count=1}\n``` {.python .cell-code}\ndef linef(x, slope, intercept):\n    y = slope * x + intercept\n    return y\n```\n:::\n\n\nWe can then evaluate the y-value of a line with say, a slope of 1 and y-interecept of 2 at x=3 with:\n\n::: {#51faa502 .cell execution_count=2}\n``` {.python .cell-code}\nm = 1\nb = 2\nlinef(3, m, b)\n```\n\n::: {.cell-output .cell-output-display execution_count=2}\n```\n5\n```\n:::\n:::\n\n\nIn the definition of `linef` we created an argument called `y`, which we modified within the function. No variable `y` was defined prior to the function definition. And even though we have called `linef`, no variable `y` exists in the notebook:\n\n::: {#8be2dfa6 .cell execution_count=3}\n``` {.python .cell-code}\nprint(y)\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">NameError</span>                                 Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[3]</span><span class=\"ansi-green-fg\">, line 1</span>\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">1</span> <span style=\"color:rgb(0,135,0)\">print</span>(<span class=\"ansi-yellow-bg\">y</span>)\n\n<span class=\"ansi-red-fg\">NameError</span>: name 'y' is not defined</pre>\n```\n:::\n\n:::\n:::\n\n\nTo understand what's going on here, let's establish a few definitions. When we set `m = 1`, we created a *mapping* from the object called `m` to the value `1`. We created a similar mappings for `b`. Likewise, when we defined the function `linef`, we created a mapping from the *object* called `linef` to the block of code defined above. **A collection of mappings is called a *namespace*.** Currently, the namespace of our notebook/module (called the module's `global` namespace) is `m`, `b`, and `linef`. Our notebook also has access to Python's `builtins` namespace. The *[scope](https://en.wikipedia.org/wiki/Scope_(computer_science))* of the notebook --- i.e., the collection of namespaces that are searched to resolve objects --- is the notebook's namespace plus the `builtins`.\n\nWhen we define a function, we define a new, *local* namespace within that function. The function's local namespace includes all of the arguments that the function takes, plus any mappings that are created within that function. So, when we called `linef(3, m, b)`, a namespace was created with local objects `x`, `slope` and `intercept`, which were mapped to `3` and the values of the global mappings `m`, and `b`, respectively. The code within `linef` was then evaluated, which created the local variable `y`. The line `return y` then passed *the value that `y` is mapped to* (not the variable `y`) back to the global namespace. At this point, *the function's namespace is deleted*, meaning that the objects `x`, `slope`, `intercept`, and `y` cease to exist.\n\nWhen we called `linef`, the value returned was just printed to screen; it was not mapped to anything. If we want the result of `linef` to persist, we need to map a variable to it so that it will exist in the notebook's namespace; e.g.:\n\n::: {#e727c472 .cell execution_count=4}\n``` {.python .cell-code}\nliney = linef(3, m, b)\nprint(liney)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5\n```\n:::\n:::\n\n\nNow let's define a variable `x = 0` in the global namespace:\n\n::: {#444dd8a3 .cell execution_count=5}\n``` {.python .cell-code}\nx = 0\n```\n:::\n\n\nIf we call `linef` again with the same arguments, we still get the same result:\n\n::: {#353a5c69 .cell execution_count=6}\n``` {.python .cell-code}\nlinef(3, m, b)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n5\n```\n:::\n:::\n\n\nBut we now have an `x` defined in the notebook's global namespace! Why did `3` get used for `x` inside the function instead of the global `x = 0`? The global `x = 0` was not used because whenever Python is evaluating a block of code, *local mappings take precedence*. So, when we called `linef(3, m, b)`, a local namespace was created in which `x` was mapped to `3`. Inside the function, the local `x` is not the same thing as the global `x` even though they share the same name.\n\nIf a function uses an object that is not defined in the local namespace, then Python will step out to the next local namespace to look for it. This process will repeat until it gets to the module's `global` namespace, followed by the `builtins`; if nothing can be found there, a `NameError` is raised.\n\nFor example, when the code inside `linef(3, m, b)` is being evaluated, 3 namespaces exist. In order of object resolution, they are:\n\n1. `linef` namespace: `{x: 3, slope: 1, intercept: 2}`\n\n2. `global` namespace: `{x: 0, m: 1, b: 2, linef: <linef code>, ... }`\n\n3. `builtin` namespace: `{+: <add>, *: <multiply>, ... }`\n\nUnderstanding nested namespaces is key to understanding how classes work.\n\n\n::: {.callout-warning}\n\nDue to the way mappings are resolved, it is possible to define a function that uses a variable from outside of its local namespace. For example:\n\n::: {#00e53928 .cell execution_count=7}\n``` {.python .cell-code}\ndef dontdothis(a):\n    return a + b\n\ndontdothis(1)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n3\n```\n:::\n:::\n\n\nHere, because `b` was not listed in `dontdothis`'s arguments (and was not defined anywhere in the function), Python ends up using the `b` defined in the notebook's `global` namespace. We therefore end up with `1 + 2`.\n\nIf it wasn't clear from the function name, **don't do this.** The danger is the output of the function can change depending on where it is called in the code even if the arguments are the same. For example, if at some later point we set `b` to a different value:\n\n::: {#240efa1e .cell execution_count=8}\n``` {.python .cell-code}\nb = 6\n```\n:::\n\n\nThen calling `dontdothis` with the same argument will yield a different result:\n\n::: {#e1430fdd .cell execution_count=9}\n``` {.python .cell-code}\ndontdothis(1)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n7\n```\n:::\n:::\n\n\nThis can lead to unexpected bugs that are hard to track down. Thus, generally, **you should include all variables needed by a function in its list of arguments.** There are some cases where this rule may need to be broken, but these are rare, and should be avoided if possible.\n\n:::\n\n## Classes\n\n### The need for classes\n\nIt is possible to write code in Python that only uses functions (this is known as [functional programming](https://en.wikipedia.org/wiki/Functional_programming)). However, in certain cases this can lead to unwieldy and difficult to manage code.\n\nAs a simple example (borrowed from [here](https://stackoverflow.com/a/33072722)), say we wanted some code to keep track of a student's progress in a class. We could do this using a dictionary:\n\n::: {#a9629177 .cell execution_count=10}\n``` {.python .cell-code}\n# create student Jane\njane = {}\njane['name'] = 'Jane'\njane['homework_grades'] = [87., 90., 82., 75., 97.]\njane['exam_grades'] = [88., 80., 94.]\n```\n:::\n\n\nYou also give your students the opportunity to earn extra credit by writing a report. Jane, the hardworking student that she is, takes advantage of this and writes an excellent report. You add that to her grades:\n\n::: {#c35f973f .cell execution_count=11}\n``` {.python .cell-code}\njane['extra_credit'] = 99.\n```\n:::\n\n\nYou now write a function to calculate averages:\n\n::: {#ede5bebf .cell execution_count=12}\n``` {.python .cell-code}\ndef average(grades):\n    if len(grades) == 0:\n        return 0\n    return float(sum(grades)) / len(grades)\n```\n:::\n\n\n... which you use in a function you write to cacluate your students' GPA:\n\n::: {#12a58d1e .cell execution_count=13}\n``` {.python .cell-code}\ndef gpa(student):\n    homeworkavg = average(student['homework_grades'])\n    examavg = average(student['exam_grades'])\n    total = average([homeworkavg, examavg]) + student['extra_credit'] \n    return min(4.0 * total / 100., 4.0)\n```\n:::\n\n\nYou use this to get Jane's score:\n\n::: {#a59cb70e .cell execution_count=14}\n``` {.python .cell-code}\nprint(gpa(jane))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4.0\n```\n:::\n:::\n\n\nNow you want to do the same for your other student, Susie:\n\n::: {#6dc9d188 .cell execution_count=15}\n``` {.python .cell-code}\nsusie = {}\nsusie['name'] = 'Susie'\nsusie['homework_grades'] = [80., 73., 77., 50., 0.]\nsusie['exam_grades'] = [70., 63., 50.]\n```\n:::\n\n\n::: {#09d7f579 .cell execution_count=16}\n``` {.python .cell-code}\nprint(gpa(susie))\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">KeyError</span>                                  Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[16]</span><span class=\"ansi-green-fg\">, line 1</span>\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">1</span> <span style=\"color:rgb(0,135,0)\">print</span>(<span class=\"ansi-yellow-bg\">gpa</span><span class=\"ansi-yellow-bg\">(</span><span class=\"ansi-yellow-bg\">susie</span><span class=\"ansi-yellow-bg\">)</span>)\n\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[13]</span><span class=\"ansi-green-fg\">, line 4</span>, in <span class=\"ansi-cyan-fg\">gpa</span><span class=\"ansi-blue-fg\">(student)</span>\n<span class=\"ansi-green-fg\">      2</span> homeworkavg = average(student[<span class=\"ansi-yellow-fg\">'</span><span class=\"ansi-yellow-fg\">homework_grades</span><span class=\"ansi-yellow-fg\">'</span>])\n<span class=\"ansi-green-fg\">      3</span> examavg = average(student[<span class=\"ansi-yellow-fg\">'</span><span class=\"ansi-yellow-fg\">exam_grades</span><span class=\"ansi-yellow-fg\">'</span>])\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">4</span> total = average([homeworkavg, examavg]) + <span class=\"ansi-yellow-bg\">student</span><span class=\"ansi-yellow-bg\">[</span><span class=\"ansi-yellow-fg ansi-yellow-bg\">'</span><span class=\"ansi-yellow-fg ansi-yellow-bg\">extra_credit</span><span class=\"ansi-yellow-fg ansi-yellow-bg\">'</span><span class=\"ansi-yellow-bg\">]</span> \n<span class=\"ansi-green-fg\">      5</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">return</span> <span style=\"color:rgb(0,135,0)\">min</span>(<span class=\"ansi-green-fg\">4.0</span> * total / <span class=\"ansi-green-fg\">100.</span>, <span class=\"ansi-green-fg\">4.0</span>)\n\n<span class=\"ansi-red-fg\">KeyError</span>: 'extra_credit'</pre>\n```\n:::\n\n:::\n:::\n\n\nOh! Susie - a bit of a slacker - didn't do the extra credit (even though she needed it more). As a result, you forgot to add an extra credit entry for her, leading to a problem with your function. You can fix this by going back and changing your `gpa` function, or by adding the missing data to Susie's dictionary. However, this highlights a disadvantage to this type of programming: the object (in this case a student, represented by a dictionary) *is not well defined.* This can lead to pitfalls when trying to write functions that will manipulate your objects.\n\n### Defining classes\n\nPython classes are a way to bundle data and functions together into logically coherent objects (this is known as [object oriented programming](https://en.wikipedia.org/wiki/Object-oriented_programming)). Like functions, they create their own local namespaces within your program within which you can manipulate objects. Unlike functions, these namespaces persist even when you are not interacting with the class.\n\nTo illustrate how classes work, let's revisit the above problem. We want an object that represents a student, which has a number of *attributes*, such as `name`, `homework_grades`, etc. To do that, we define a `class`:\n\n::: {#4540630c .cell execution_count=17}\n``` {.python .cell-code}\nclass Student:\n    \"\"\"Stores information about students.\"\"\"\n\n    def __init__(self, name):\n        self.name = name\n        self.homework_grades = []\n        self.exam_grades = []\n        self.extra_credit = 0\n\n    def homework_avg(self):\n        \"\"\"Average homework grade.\"\"\"\n        return average(self.homework_grades)\n\n    def exam_avg(self):\n        \"\"\"Average exam grade.\"\"\"\n        return average(self.exam_grades)\n\n    def gpa(self):\n        \"\"\"GPA (on a 4.0 scale).\"\"\"\n        total = average([self.homework_avg(), self.exam_avg()]) + self.extra_credit\n        return min(4.0 * total / 100., 4.0)\n```\n:::\n\n\nNow we create `Student` *instances*, one for Jane, and one for Susie:\n\n::: {#672f9b0e .cell execution_count=18}\n``` {.python .cell-code}\njane = Student('Jane')\njane.homework_grades = [87., 90., 82., 75., 97.]\njane.exam_grades = [88., 80., 94.]\njane.extra_credit = 99.\n\nsusie = Student('Susie')\nsusie.homework_grades = [80., 73., 77., 50., 0.]\nsusie.exam_grades = [70., 63., 50.]\n```\n:::\n\n\nWe can now get their GPAs:\n\n::: {#9477ad83 .cell execution_count=19}\n``` {.python .cell-code}\njane.gpa()\n```\n\n::: {.cell-output .cell-output-display execution_count=19}\n```\n4.0\n```\n:::\n:::\n\n\n::: {#f7b2d004 .cell execution_count=20}\n``` {.python .cell-code}\nsusie.gpa()\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\n2.34\n```\n:::\n:::\n\n\nWhat did we do here? First, we defined the class `Student`, to which we added methods `__init__`, `homework_avg`, `exam_avg`, and `gpa`. No code was executed until we created an *instance* of `Student` by calling:\n\n::: {#cebf3300 .cell execution_count=21}\n``` {.python .cell-code}\njane = Student('Jane')\n```\n:::\n\n\nAt this point, a local namespace called `jane` was created, which contained the mappings:\n\n```{text}\n{name: 'Jane', homework_grades: [], exam_grades: [], extra_credit: None,\n homework_avg: <Student.homework_avg code>, exam_avg: <Student.exam_avg code>,\n gpa: <Student.gpa code>}\n```\n\nThis is similar to what happens when a function is called. However, unlike a function, the namespace persisted after this line, allowing us to access its attributes with `.`; e.g., `jane.homework_grades`. Once we populated the relevant attributes, we were then able to call `gpa` to get Jane's GPA.\n\n### What's the deal with `self`?\n\nFunctions that are defined in a class are called *methods*. Their purpose is to act on a class instance's attributes. In our `Student` example there were four methods: `__init__`, `homework_avg`, `exam_avg`, and `gpa`. All of these took `self` as their first argument. Why?\n\nIn order for a method to act on an instance's attributes, it must have some way to reference the class *instance*. For example, when we call `jane.gpa()`, we want the function `Student.gpa` to act on *Jane*'s grades. This is the purpose of `self`: it represents the class instance, so that we can access attributes of the instance within the function definition.\n\nNote that when we called `jane.gpa()` we did not need to provide any arguments. This is because **Python automatically adds the class instance as the first argument when a method is called.** So:\n\n- All class method definitions must have `self` as their first argument. (With two exceptions; see Appendix, below.)\n\n- When calling a method of a class instance, you do not pass the instance in the function arguments.\n \nIn other words...\n\n**Correct:**\n\n::: {#43d4a6fe .cell execution_count=22}\n``` {.python .cell-code}\njane.gpa()\n```\n\n::: {.cell-output .cell-output-display execution_count=22}\n```\n0.0\n```\n:::\n:::\n\n\n**Not correct:**\n\n::: {#d2d2d7d1 .cell execution_count=23}\n``` {.python .cell-code}\njane.gpa(jane)\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">TypeError</span>                                 Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[23]</span><span class=\"ansi-green-fg\">, line 1</span>\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">1</span> <span class=\"ansi-yellow-bg\">jane</span><span class=\"ansi-yellow-bg\">.</span><span class=\"ansi-yellow-bg\">gpa</span><span class=\"ansi-yellow-bg\">(</span><span class=\"ansi-yellow-bg\">jane</span><span class=\"ansi-yellow-bg\">)</span>\n\n<span class=\"ansi-red-fg\">TypeError</span>: Student.gpa() takes 1 positional argument but 2 were given</pre>\n```\n:::\n\n:::\n:::\n\n\nAlthough you can do:\n\n::: {#15ead86a .cell execution_count=24}\n``` {.python .cell-code}\nStudent.gpa(jane)\n```\n\n::: {.cell-output .cell-output-display execution_count=24}\n```\n0.0\n```\n:::\n:::\n\n\n*Note:* The name `self` in a method definition isn't special. What matters is the argument order: the *first* argument of the class method is assumed to be the class instance, regardless of what it is named. Using `self` for this is just a convention.\n\n### The `__init__` method\n\nFor the most part, you can add any number of methods with various names to a class. However, there are a few special method names that Python recognizes (all of which begin and end with `__`). The most common of these is the  `__init__` method.\n\nThe `__init__` method is called while the class is initialized. The arguments of `__init__` determine what arguments need to be passed to the class when it is initialized. In our example, `Student.__init__` was defined as needing `name` (in addition to `self`, which is always required). As a result, when we initialized the class we had to pass in a string representing the student's name.\n\nThe `__init__` method is used to add attributes to a class and set their initial values. It is not necessary to have an `__init__` method, however. Nor must attributes be assigned in `__init__`. Attributes may be added to a class instance *after* the class is initialized. For example:\n\n::: {#0fc97133 .cell execution_count=25}\n``` {.python .cell-code}\nclass Foo:\n    pass\n\n\nfoo = Foo()\nfoo.bar = 10.\nprint(foo.bar)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10.0\n```\n:::\n:::\n\n\nThe catch is that any attribute added to an instance *only exists for that instance*. This means that if we create another instance of `Foo`:\n\n::: {#a7f73dca .cell execution_count=26}\n``` {.python .cell-code}\nfoo2 = Foo()\n```\n:::\n\n\nIt will *not* have a `bar` attribute:\n\n::: {#92d468da .cell execution_count=27}\n``` {.python .cell-code}\nprint(foo2.bar)\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">AttributeError</span>                            Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[27]</span><span class=\"ansi-green-fg\">, line 1</span>\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">1</span> <span style=\"color:rgb(0,135,0)\">print</span>(<span class=\"ansi-yellow-bg\">foo2</span><span class=\"ansi-yellow-bg\">.</span><span class=\"ansi-yellow-bg\">bar</span>)\n\n<span class=\"ansi-red-fg\">AttributeError</span>: 'Foo' object has no attribute 'bar'</pre>\n```\n:::\n\n:::\n:::\n\n\nThe benefit of `__init__` is that it ensures that all instances of a class have at least the attributes that are set within it.\n\n### Class vs. instance variables\n\nIn the `Student` example above, we created four attributes in the `__init__` method -- `name`, `homework_grades`, `exam_grades`, and `extra_credit` -- and assigned values to them. Since the values of the variables are assigned at class initialization these are known as *instance variables*.\n\nIt is also possible to create what are called *class variables*. These are variables whose values are assigned in the class definition. For example, let's redefine our `Student` class to hava class variable called `university`, which we'll set to Syracuse:\n\n::: {#81e9dfb1 .cell execution_count=28}\n``` {.python .cell-code}\nclass Student:\n    \"\"\"Stores information about students.\"\"\"\n\n    university = 'Syracuse'\n\n    def __init__(self, name):\n        self.name = name\n        self.homework_grades = []\n        self.exam_grades = []\n        self.extra_credit = 0\n\n    def homework_avg(self):\n        \"\"\"Average homework grade.\"\"\"\n        return average(self.homework_grades)\n\n    def exam_avg(self):\n        \"\"\"Average exam grade.\"\"\"\n        return average(self.exam_grades)\n\n    def gpa(self):\n        \"\"\"GPA (on a 4.0 scale).\"\"\"\n        total = average([self.homework_avg(), self.exam_avg()]) + self.extra_credit\n        return min(4.0 * total / 100., 4.0)\n```\n:::\n\n\nNow create two more students and see what their universities are:\n\n::: {#ec731977 .cell execution_count=29}\n``` {.python .cell-code}\nbob = Student('Bob')\njoe = Student('Joe')\n\nprint(bob.name, bob.university)\nprint(joe.name, joe.university)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBob Syracuse\nJoe Syracuse\n```\n:::\n:::\n\n\nWe can see that despite having different names, both Bob and Joe have the same university without having to set it. What happens if we change Bob's university? Does that affect Joe, or any other new `Student`?\n\n::: {#b12132cf .cell execution_count=30}\n``` {.python .cell-code}\nbob.university = 'Cornell'\nmiranda = Student('Miranda')\nfor student in [bob, joe, miranda]:\n    print(student.name, student.university)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBob Cornell\nJoe Syracuse\nMiranda Syracuse\n```\n:::\n:::\n\n\nNope! When we changed Bob's university, it only reset Bob's university attribute, but left Joe and Miranda alone. But what happens if we change `Student.university`? Let's see how that affects a new student, as well as our current students:\n\n::: {#222cd6d8 .cell execution_count=31}\n``` {.python .cell-code}\nStudent.university = 'Stanford'\nsam = Student('Sam')\nfor student in [bob, joe, miranda, sam]:\n    print(student.name, student.university)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBob Cornell\nJoe Stanford\nMiranda Stanford\nSam Stanford\n```\n:::\n:::\n\n\nJoe and Miranda's university have now also changed to Stanford! What's going on? When the class is initialized, the values for all class variables point to value that is saved in the class definition. In other words, `joe.university` points to whatever `Student.university` is set to. Consequently, if you change the value of the class variable, all instances of that class will immediately have the same value. However, if you change the value of an instance's class variable (as we did with Bob's university) then that instance's variable now points to whatever you set the new value to. In Bob's case, the `university` attribute now points to the string 'Cornell' rather than to `Student.university`. That is why Bob was unaffected by the change.\n\nClass variables can be extremely useful for setting common parameters across multiple instances. Just be careful about modifying a class variable directly!\n\n\n## Further reading\n\n1. The longer version of this tutorial, which includes things about class inheritance and abstract base classes: [link](https://github.com/SyracuseUniversity/ospo-workshop-advpython/blob/main/session1/tutorial.ipynb)\n\n2. Python's tutorial on classes, which includes more details on namespaces and scope: https://docs.python.org/3.7/tutorial/classes.html\n\n3. Another tutorial on object oriented programming in Python: https://jeffknupp.com/blog/2014/06/18/improve-your-python-python-classes-and-object-oriented-programming/\n\n4. More on method resolution order, from the former \"Benevolent Dictator for Life\" [Guido van Rossum](https://en.wikipedia.org/wiki/Guido_van_Rossum): http://python-history.blogspot.com/2010/06/method-resolution-order.html\n\n\n# Appendix\n\nSome extra stuff that you may or may not find interesting.\n\n## A. Decorators\n\nConsider the following modification of our `Student` class:\n\n::: {#8544e3a5 .cell execution_count=32}\n``` {.python .cell-code}\nclass Student:\n    \"\"\"Stores information about students.\"\"\"\n\n    def __init__(self, name):\n        self.name = name\n        self.homework_grades = []\n        self.exam_grades = []\n        self.extra_credit = 0\n\n    @classmethod\n    def from_dict(cls, sdict):\n        \"\"\"Initialize a Student using the given dictionary.\"\"\"\n        student = cls(sdict['name'])\n        if 'homework_grades' in sdict:\n            student.homework_grades = sdict['homework_grades']\n        if 'exam_grades' in sdict:\n            student.exam_grades = sdict['exam_grades']\n        if 'extra_credit' in sdict:\n            student.extra_credit = sdict['extra_credit']\n        return student\n\n    @staticmethod\n    def avg(values):\n        if len(values) == 0:\n            return 0\n        return sum(values) / float(len(values))\n\n    @property\n    def homework_avg(self):\n        \"\"\"Average homework grade.\"\"\"\n        return self.avg(self.homework_grades)\n\n    @property\n    def exam_avg(self):\n        \"\"\"Average exam grade.\"\"\"\n        return self.avg(self.exam_grades)\n\n    @property\n    def gpa(self):\n        \"\"\"GPA (on a 4.0 scale).\"\"\"\n        score = self.avg([self.homework_avg, self.exam_avg]) + self.extra_credit\n        return min(4.0 * score / 100., 4.0)\n```\n:::\n\n\nWhat are all of those things with `@` before the function definitions? And why don't the `from_dict` and `avg` methods not have `self` as their first arguments?!?\n\nThe names beginning with `@`, such as `@classmethod`, are called *decorators*. Essentially, decorators are wrappers around functions that modify the behavior of that function. They can be used on any Python function, but they are most often seen in classes.\n\nUsing and creating decorators is a large topic itself, the details of which we won't get into here (if you're interested, see [here](https://realpython.com/primer-on-python-decorators/) for an excellent tutorial). However, there are three predefined decorators in the Python `builtins` that often come up in class definitions that I want highlight here: `@classmethod`, `@staticmethod`, and `@property`.\n\n### @classmethod\n\nThe `@classmethod` decorator modifies methods so that instead of taking an *instance* of a class as the first argument (what we normally call `self`) it takes the *class itself* (which we normally call `cls`). This is typically used to provide a way to instantiate a class using alternate input arguments than what is defined in `__init__`. For example, say we had a dictionary that specifies all of the information about Susie:\n\n::: {#525c596a .cell execution_count=33}\n``` {.python .cell-code}\nsusie_dict = {}\nsusie_dict['name'] = 'Susie'\nsusie_dict['homework_grades'] = [80., 73., 77., 50., 0.]\nsusie_dict['exam_grades'] = [70., 63., 50.]\n```\n:::\n\n\nWe can now instantiate a `Student` representation of Susie using the `from_dict` method:\n\n::: {#bc83cf6b .cell execution_count=34}\n``` {.python .cell-code}\nsusie = Student.from_dict(susie_dict)\n\nprint(susie.name)\nprint(susie.homework_grades)\nprint(susie.exam_grades)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSusie\n[80.0, 73.0, 77.0, 50.0, 0.0]\n[70.0, 63.0, 50.0]\n```\n:::\n:::\n\n\nNotice that when we used `from_dict` we only provided the dictionary, even though the definition of `from_dict` had two arguments, `cls` and `sdict`. As with normal methods, `@classmethod` automatically adds in the class as the first argument.\n\n### @staticmethod\n\nThe `@staticmethod` decorator modifies methods so that the class instance `self` is *not* automatically added when the method is called. As a result, we do not need to reserve the first argument in the definition of a `@staticmethod`. We see that in the above example: `avg` takes a single argument `values`, which is a list of values to calculate an average for.\n\nSince methods wrapped with `@staticmethod` do not do any automatic substitutions, it's possible to use them without needing to create a class instance. For example:\n\n::: {#f0d7b7e9 .cell execution_count=35}\n``` {.python .cell-code}\nStudent.avg([60., 70.])\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```\n65.0\n```\n:::\n:::\n\n\nIn fact, we could have just defined `avg` outside of `Student` in the global namespace (which is what we did above, using our global function `average`). In that case we would of called `avg(...)` instead of `self.avg(...)` inside of `Student`.\n\nSo why use `@staticmethod`? Its main purpose is to provide a function that is heavily used by a class, but may have little meaning outside of the class. This can make code a easier to read and understand (\"[syntactic sugar](https://en.wikipedia.org/wiki/Syntactic_sugar)\"). Basically, `@staticmethod` is a way of logically organizing functions.\n\n### @property\n\nThe `@property` decorator is another form of syntactic sugar that modifies how a method is called. Basically, it makes a method look like an attribute.\n\nFor example, in the above `homework_avg`, `exam_avg`, and `gpa` were all methods. Normally you would call them like `susie.gpa()` (as we did in the [Classes](#Classes) section). However, because we stuck the `@property` decorator on each of these methods, we instead do:\n\n::: {#f490639b .cell execution_count=36}\n``` {.python .cell-code}\nsusie.gpa\n```\n\n::: {.cell-output .cell-output-display execution_count=36}\n```\n2.34\n```\n:::\n:::\n\n\nIn other words, we no longer include the `()` after the name. Note that `@property` **only works with methods that take no arguments.**\n\nThe `@property` is used when we want to run some additional code under the hood when an attribute is accessed. It is typically paired with a \"setter\", which allows us to also run some code when an attribute is set. For example:\n\n::: {#6de4ba3e .cell execution_count=37}\n``` {.python .cell-code}\nclass Star:\n    _mass = None\n\n    @property\n    def mass(self):\n        if self._mass is None:\n            raise ValueError(\"no mass set\")\n        return self._mass\n\n    @mass.setter\n    def mass(self, value):\n        if value <= 0:\n            raise ValueError(\"mass must be > 0\")\n        self._mass = value\n```\n:::\n\n\n::: {#747eec5d .cell execution_count=38}\n``` {.python .cell-code}\nstar = Star()\n```\n:::\n\n\n::: {#6b4f4445 .cell execution_count=39}\n``` {.python .cell-code}\nprint(star.mass)\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">ValueError</span>                                Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[39]</span><span class=\"ansi-green-fg\">, line 1</span>\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">1</span> <span style=\"color:rgb(0,135,0)\">print</span>(<span class=\"ansi-yellow-bg\">star</span><span class=\"ansi-yellow-bg\">.</span><span class=\"ansi-yellow-bg\">mass</span>)\n\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[37]</span><span class=\"ansi-green-fg\">, line 7</span>, in <span class=\"ansi-cyan-fg\">Star.mass</span><span class=\"ansi-blue-fg\">(self)</span>\n<span class=\"ansi-green-fg\">      4</span> <span style=\"color:rgb(175,0,255)\">@property</span>\n<span class=\"ansi-green-fg\">      5</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">def</span><span style=\"color:rgb(188,188,188)\"> </span><span class=\"ansi-blue-fg\">mass</span>(<span style=\"color:rgb(0,135,0)\">self</span>):\n<span class=\"ansi-green-fg\">      6</span>     <span style=\"font-weight:bold;color:rgb(0,135,0)\">if</span> <span style=\"color:rgb(0,135,0)\">self</span>._mass <span style=\"font-weight:bold;color:rgb(175,0,255)\">is</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">None</span>:\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">7</span>         <span style=\"font-weight:bold;color:rgb(0,135,0)\">raise</span> <span style=\"font-weight:bold;color:rgb(215,95,95)\">ValueError</span>(<span class=\"ansi-yellow-fg\">\"</span><span class=\"ansi-yellow-fg\">no mass set</span><span class=\"ansi-yellow-fg\">\"</span>)\n<span class=\"ansi-green-fg\">      8</span>     <span style=\"font-weight:bold;color:rgb(0,135,0)\">return</span> <span style=\"color:rgb(0,135,0)\">self</span>._mass\n\n<span class=\"ansi-red-fg\">ValueError</span>: no mass set</pre>\n```\n:::\n\n:::\n:::\n\n\n::: {#5661efcc .cell execution_count=40}\n``` {.python .cell-code}\nstar.mass = 10.\nprint(star.mass)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n10.0\n```\n:::\n:::\n\n\n::: {#33916e45 .cell execution_count=41}\n``` {.python .cell-code}\nstar2 = Star()\nstar2.mass = -3\n```\n\n::: {.cell-output .cell-output-error}\n\n::: {.ansi-escaped-output}\n```{=html}\n<pre><span class=\"ansi-red-fg\">---------------------------------------------------------------------------</span>\n<span class=\"ansi-red-fg\">ValueError</span>                                Traceback (most recent call last)\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[41]</span><span class=\"ansi-green-fg\">, line 2</span>\n<span class=\"ansi-green-fg\">      1</span> star2 = Star()\n<span class=\"ansi-green-fg\">----&gt; </span><span class=\"ansi-green-fg\">2</span> <span class=\"ansi-yellow-bg\">star2</span><span class=\"ansi-yellow-bg\">.</span><span class=\"ansi-yellow-bg\">mass</span> = -<span class=\"ansi-green-fg\">3</span>\n\n<span class=\"ansi-cyan-fg\">Cell</span><span class=\"ansi-cyan-fg\"> </span><span class=\"ansi-green-fg\">In[37]</span><span class=\"ansi-green-fg\">, line 13</span>, in <span class=\"ansi-cyan-fg\">Star.mass</span><span class=\"ansi-blue-fg\">(self, value)</span>\n<span class=\"ansi-green-fg\">     10</span> <span style=\"color:rgb(175,0,255)\">@mass</span>.setter\n<span class=\"ansi-green-fg\">     11</span> <span style=\"font-weight:bold;color:rgb(0,135,0)\">def</span><span style=\"color:rgb(188,188,188)\"> </span><span class=\"ansi-blue-fg\">mass</span>(<span style=\"color:rgb(0,135,0)\">self</span>, value):\n<span class=\"ansi-green-fg\">     12</span>     <span style=\"font-weight:bold;color:rgb(0,135,0)\">if</span> value &lt;= <span class=\"ansi-green-fg\">0</span>:\n<span class=\"ansi-green-fg\">---&gt; </span><span class=\"ansi-green-fg\">13</span>         <span style=\"font-weight:bold;color:rgb(0,135,0)\">raise</span> <span style=\"font-weight:bold;color:rgb(215,95,95)\">ValueError</span>(<span class=\"ansi-yellow-fg\">\"</span><span class=\"ansi-yellow-fg\">mass must be &gt; 0</span><span class=\"ansi-yellow-fg\">\"</span>)\n<span class=\"ansi-green-fg\">     14</span>     <span style=\"color:rgb(0,135,0)\">self</span>._mass = value\n\n<span class=\"ansi-red-fg\">ValueError</span>: mass must be &gt; 0</pre>\n```\n:::\n\n:::\n:::\n\n\n",
    "supporting": [
      "python-4_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}